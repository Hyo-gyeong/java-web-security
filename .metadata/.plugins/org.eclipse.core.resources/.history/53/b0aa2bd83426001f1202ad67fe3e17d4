// 컴퓨터학과, 20190975, 신효경
package research_center;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Scanner;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import enums.Algorithm;
import enums.Extension;
import enums.FilePath;
import enums.Message;
import key_manager.keyManagerMain;
import sign.verificationMode;


public class ResearchCenterMain {
	private static StringBuilder sb;
	public static Key loadKeyFromFile(String fileName) throws IOException, ClassNotFoundException {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))) {
            return (Key) in.readObject();
        }
    }
	
    public static byte[] decrypt(byte[] cipherText, SecretKey sk) throws Exception {
        Cipher cipher = Cipher.getInstance(Algorithm.CIPHER_ALGORITHM.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, sk);
        byte[] decryptedBytes = cipher.doFinal(cipherText);
        return decryptedBytes;
    }
    
    public static SecretKey decryptSecretKey(byte[] encryptedKey, PrivateKey pk) throws Exception {
        Cipher cipher = Cipher.getInstance(pk.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, pk);
        byte[] decryptedKey = cipher.doFinal(encryptedKey);
        
        // SecretKey 복원, AES 알고리즘 사용
        return new SecretKeySpec(decryptedKey, Algorithm.CIPHER_ALGORITHM.getAlgorithm());
    }
    
    public static byte[] readFromFile(String filePath) {
        byte[] fileData = null;
        
        try (FileInputStream in = new FileInputStream(filePath)) {
            fileData = in.readAllBytes();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        return fileData;
    }    
		
	public static byte[] SHA1HashMedicalRecord(String mr) throws NoSuchAlgorithmException, IOException {
		byte[] digest = null;
		
		MessageDigest md = MessageDigest.getInstance(Algorithm.MD_ALGORITHM.getAlgorithm());
		md.update(mr.getBytes());
		digest = md.digest();
		
		return digest;
	}

	public static void run(Scanner sc) throws Exception {		
		//0. 센터 사설키로 대칭키 얻기
		String centerPId = keyManagerMain.getCenterPrivateId();
		sb = new StringBuilder();
		sb.append(FilePath.PK.getPath())
			.append(centerPId)
			.append(Extension.KEY_EXT.getExtension());
		PrivateKey pk = (PrivateKey) loadKeyFromFile(sb.toString());
		byte[] encryptedKey = readFromFile(FilePath.RC_ENCRYPTED_SK.getPath());
		SecretKey sk = decryptSecretKey(encryptedKey, pk);

		// 비밀키를 이용해서 2개의 파일 해독
		// 1. 의료 기록
		byte[] secretMR = readFromFile(FilePath.RC_SECRET_MR.getPath());
		byte[] byteMR = decrypt(secretMR, sk);
		String MR = new String(byteMR, StandardCharsets.UTF_8); //byte array to string
        
        // 2. 해시화되고 비밀키로 암호화된 의료 기록
		byte[] secretHashedMR = readFromFile(FilePath.RC_SECRET_HASHED_MR.getPath());
		byte[] byteHashedMR = decrypt(secretHashedMR, sk);
		
		// 병원의 공개키로 2번(해시화되고 비밀키로 암호화된 의료 기록) 복호화
		String hospitalPubId = keyManagerMain.getHospitalPublicId();
		sb = new StringBuilder();
		sb.append(FilePath.PubK.getPath())
			.append(hospitalPubId)
			.append(Extension.KEY_EXT.getExtension());
		PublicKey hospitalPK = (PublicKey) loadKeyFromFile(sb.toString());
		byte[] hashedMR = SHA1HashMedicalRecord(MR);
		
		// 파일 비교 검증
		boolean result = verificationMode.verify(hospitalPK, hashedMR, byteHashedMR);
        System.out.println(Message.SIGN_RESULT.getMessage() + result);
        System.out.println(Message.MEDICAL_RECORD.getMessage());
        System.out.println(MR);
        
		sc.close();
	}
}
