// 컴퓨터학과, 20190975, 신효경
package hospital;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Scanner;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;

import key_manager.CreateSaveSymKey;
import key_manager.keyManagerMain;
import sign.signMode;
import enums.Extension;
import enums.FilePath;
import enums.Message;


public class HospitalMain {	
	public static Key loadKeyFromFile(String fileName) throws IOException, ClassNotFoundException {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))) {
            return (Key) in.readObject();
        }
    }
	
	public static void saveHashToFile(byte[] hashValue, String filePath) throws IOException {
		try (FileOutputStream out = new FileOutputStream(filePath)) {
            out.write(hashValue);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }	
	}
	
	public static String getMedicalRecord(Hospital hospital) throws CloneNotSupportedException {
		StringBuilder sb = new StringBuilder();
		sb.append(hospital.getDoctor().toString());
		sb.append("\n");
		sb.append(hospital.getPatient().toString());
		sb.append("\n");
		sb.append(hospital.getMedicalRecord().toString());
		
		return sb.toString();
	}
	
	public static byte[] SHA1HashMedicalRecord(String mr) throws NoSuchAlgorithmException, IOException {
		byte[] digest = null;
		
		MessageDigest md = MessageDigest.getInstance("SHA-1");
		md.update(mr.getBytes());
		digest = md.digest();
		return digest;
	}
	
	public static void encryptAndSaveToFile(SecretKey sk, byte[] data, String filePath) throws Exception {
		Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, sk);
        
        try(FileOutputStream bos = new FileOutputStream(filePath);
				CipherOutputStream cos = new CipherOutputStream(bos, cipher)){
			cos.write(data);
			cos.flush();			
		} catch(IOException e) {
			e.printStackTrace();
		}
    }	
    
    public static byte[] encryptSecretKey(SecretKey sk, PublicKey pk) throws Exception {
    	byte[] byteKey = sk.getEncoded();
        
        // RSA로 암호화
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, pk);
        return cipher.doFinal(byteKey);
    }
	
	public static boolean run(Hospital hospital, Scanner sc) throws Exception {
		StringBuilder sb;
		
		//대칭키 생성
		SecretKey sk = CreateSaveSymKey.create();
		System.out.println(Message.SYMMETRIC_KEY_GENERATED.getMessage());
		
		// 개인키 가져오기
		String hospitalPId = keyManagerMain.getHospitalPrivateId();
		sb = new StringBuilder()
				.append(FilePath.PK.getPath())
				.append(hospitalPId)
				.append(Extension.KEY_EXT.getExtension());
		PrivateKey hospitalPrivateKey = (PrivateKey) loadKeyFromFile(sb.toString());

		// 환자의 의료 기록 가져오기
		String MR = getMedicalRecord(hospital);
		// 환자의 의료 기록을 대칭키로 암호화 하여 파일에 저장
		encryptAndSaveToFile(sk, MR.getBytes(), FilePath.HOSPITAL_SECRET_MR.getPath());
		
		// 환자의 의료 기록을 해시화한 값을 병원의 사설키로 암호화
		byte[] hashedMR = SHA1HashMedicalRecord(MR);
		byte[] signature = signMode.sign(hashedMR, hospitalPrivateKey);
		// 위의 값을 대칭키로 암호화하여 파일에 저장
		encryptAndSaveToFile(sk, signature, FilePath.HOSPITAL_SECRET_HASHED_MR.getPath());
		
		// 대칭키를 센터의 공개키로 암호화
		String centerPubId = keyManagerMain.getCenterPublicId();
		sb = new StringBuilder();
		sb.append(FilePath.PubK.getPath())
			.append(centerPubId)
			.append(Extension.KEY_EXT.getExtension());
		PublicKey centerPubK = (PublicKey) loadKeyFromFile(sb.toString());
		byte[] encryptedKey = encryptSecretKey(sk, centerPubK);
		
		saveHashToFile(encryptedKey, FilePath.HOSPITAL_ENCRYPTED_SK.getPath());
		System.out.println(Message.DE_CREATED.getMessage());
		
		String answer;
		do{
			System.out.print(Message.TRANSMISSION_CHOICE.getMessage());
			answer = sc.next();
			if (answer.equals(Message.YES.getMessage())) {
				Path fromSecretMR = Paths.get(FilePath.HOSPITAL_SECRET_MR.getPath());
				Path toSecretMR = Paths.get(FilePath.RC_SECRET_MR.getPath());
				Path fromSecretHashedMR = Paths.get(FilePath.HOSPITAL_SECRET_HASHED_MR.getPath());
				Path toSecretHashedMR = Paths.get(FilePath.RC_SECRET_HASHED_MR.getPath());
				Path fromSKPath = Paths.get(FilePath.HOSPITAL_ENCRYPTED_SK.getPath());
				Path toSKPath = Paths.get(FilePath.RC_ENCRYPTED_SK.getPath());
				try {
					//파일의 경로를 바꿔서 이동시킴
					Files.move(fromSecretMR, toSecretMR, StandardCopyOption.REPLACE_EXISTING);
					Files.move(fromSecretHashedMR, toSecretHashedMR, StandardCopyOption.REPLACE_EXISTING);
					Files.move(fromSKPath, toSKPath, StandardCopyOption.REPLACE_EXISTING);
				} catch (Exception e) {
				   e.printStackTrace();
				}
				return true;
			}
			else if (answer.equals(Message.NO.getMessage())) {
				System.out.println(Message.TRANSMISSION_CANCELED.getMessage());
				return false;
			}else {
				System.out.println(Message.WRONG_INPUT.getMessage());
			}
		}while(!answer.equals(Message.QUIT.getMessage()));
		
		System.out.println(Message.PROGRAM_TERMINATE.getMessage());
		return false;
	}
}
